import * as THREE from 'three';

export class Atom {
    constructor(element, position, id) {
        this.element = element;
        // Ensure position is a Vector3
        this.position = new THREE.Vector3(position.x, position.y, position.z);
        this.id = id;
        this.bonds = [];
        this.mesh = null;
        this.selected = false;
    }
}

export class Bond {
    constructor(atom1, atom2, order = 1) {
        this.atom1 = atom1;
        this.atom2 = atom2;
        this.order = order;
        this.mesh = null;
        this.id = `${atom1.id}-${atom2.id}`;
    }
}

export class Molecule {
    constructor() {
        this.atoms = [];
        this.bonds = [];
        this.nextAtomId = 1;
    }

    addAtom(element, position) {
        const atom = new Atom(element, position, this.nextAtomId++);
        this.atoms.push(atom);
        return atom;
    }

    addBond(atom1, atom2, order = 1) {
        // Check if bond already exists
        const existing = this.bonds.find(b =>
            (b.atom1 === atom1 && b.atom2 === atom2) ||
            (b.atom1 === atom2 && b.atom2 === atom1)
        );
        if (existing) return existing;

        const bond = new Bond(atom1, atom2, order);
        this.bonds.push(bond);
        atom1.bonds.push(bond);
        atom2.bonds.push(bond);
        return bond;
    }

    removeBond(bond) {
        // Remove references from atoms
        const idx1 = bond.atom1.bonds.indexOf(bond);
        if (idx1 !== -1) bond.atom1.bonds.splice(idx1, 1);

        const idx2 = bond.atom2.bonds.indexOf(bond);
        if (idx2 !== -1) bond.atom2.bonds.splice(idx2, 1);

        // Remove from molecule bonds array
        const idx = this.bonds.indexOf(bond);
        if (idx !== -1) this.bonds.splice(idx, 1);
    }

    getBond(atom1, atom2) {
        return this.bonds.find(b =>
            (b.atom1 === atom1 && b.atom2 === atom2) ||
            (b.atom1 === atom2 && b.atom2 === atom1)
        );
    }

    removeAtom(atom) {
        this.atoms = this.atoms.filter(a => a !== atom);
        // Remove associated bonds
        this.bonds = this.bonds.filter(b => {
            if (b.atom1 === atom || b.atom2 === atom) {
                // Remove bond from other atom's list
                const other = b.atom1 === atom ? b.atom2 : b.atom1;
                other.bonds = other.bonds.filter(ob => ob !== b);
                return false;
            }
            return true;
        });
    }

    clear() {
        this.atoms = [];
        this.bonds = [];
        this.nextAtomId = 1;
    }

    fromXYZ(xyzString) {
        this.clear();
        const lines = xyzString.trim().split('\n');
        if (lines.length < 3) return; // Invalid XYZ

        // First line is atom count (skip or use)
        // Second line is comment
        // Subsequent lines: Element X Y Z

        for (let i = 2; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;

            const parts = line.split(/\s+/);
            if (parts.length >= 4) {
                const element = parts[0];
                const x = parseFloat(parts[1]);
                const y = parseFloat(parts[2]);
                const z = parseFloat(parts[3]);

                if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                    this.addAtom(element, new THREE.Vector3(x, y, z));
                }
            }
        }
    }

    toXYZ() {
        let output = `${this.atoms.length}\nGenerated by WebMolEditor\n`;
        for (const atom of this.atoms) {
            const x = atom.position.x.toFixed(7);
            const y = atom.position.y.toFixed(7);
            const z = atom.position.z.toFixed(7);
            output += `${atom.element.padEnd(2)} ${x.padStart(15)} ${y.padStart(15)} ${z.padStart(15)}\n`;
        }
        return output;
    }
}
